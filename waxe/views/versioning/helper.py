import os
import locale
import pysvn
from waxe import browser
from waxe import diff
import tempfile


STATUS_NORMAL = 'normal'
STATUS_ADDED = 'added'
STATUS_DELETED = 'deleted'
STATUS_MODIFED = 'modified'
STATUS_CONFLICTED = 'conflicted'
STATUS_UNVERSIONED = 'unversioned'
STATUS_MISSING = 'missing'

PYSVN_STATUS_MAPPING = {
    pysvn.wc_status_kind.normal: STATUS_NORMAL,
    pysvn.wc_status_kind.added: STATUS_ADDED,
    pysvn.wc_status_kind.deleted: STATUS_DELETED,
    pysvn.wc_status_kind.modified: STATUS_MODIFED,
    pysvn.wc_status_kind.conflicted: STATUS_CONFLICTED,
    pysvn.wc_status_kind.unversioned: STATUS_UNVERSIONED,
    pysvn.wc_status_kind.missing: STATUS_MISSING,
}


def is_conflicted(so, lis):
    """
    :param so: the StatusObject to check
    :type so: StatusObject
    :param lis: list of absolute path of conflicted files
    :type lis: list of str

    Check that the given so is not generated by a conflicted file.
    """
    for abspath in lis:
        if so.abspath.startswith('%s.mine' % abspath):
            return True
        if so.abspath.startswith('%s.r' % abspath):
            return True
    return False


class StatusObject(object):

    def __init__(self, abspath, relpath, status):
        self.abspath = abspath
        self.relpath = relpath
        self.status = status

    def __repr__(self):
        return '<%s: %s>' % (self.relpath.encode('utf-8'), self.status)

    def __eq__(self, other):
        for p in ['abspath', 'relpath', 'status']:
            if getattr(self, p) != getattr(other, p):
                return False
        return True


class PysvnVersioning(object):

    def __init__(self, client, root_path):
        self.client = client
        self.root_path = root_path

    def _status(self, abspath, changes, short=True):
        lis = []
        for f in reversed(changes):
            status = PYSVN_STATUS_MAPPING[f.text_status]
            fpath = f.path.encode(locale.getpreferredencoding())
            isdir = os.path.isdir(fpath)
            # Don't skip the root if it's a file, we want to get the file
            # status
            if f.path == abspath and short and isdir:
                if status == STATUS_UNVERSIONED:
                    # The root path is unversioned so all children are
                    # unversioned
                    for sf in sum(browser.get_files(f.path,
                                                    abspath,
                                                    relative=False), []):
                        relpath = browser.relative_path(sf, self.root_path)
                        lis += [StatusObject(sf, relpath, STATUS_UNVERSIONED)]
                continue

            if short and status == STATUS_NORMAL and isdir:
                # For short status we just want to know if a normal folder has
                # some updates
                res = self.client.status(f.path, recurse=True, get_all=False)
                if res:
                    relpath = browser.relative_path(f.path, self.root_path)
                    lis += [StatusObject(f.path, relpath, STATUS_MODIFED)]
                continue

            if not short and status == STATUS_UNVERSIONED and isdir:
                # For full status we want to get all the files under an
                # unversioned folder
                # NOTE: we don't get the folders here since we don't care of
                # the empty ones
                for sf in browser.get_all_files(f.path,
                                                    abspath,
                                                    relative=False)[1]:
                    relpath = browser.relative_path(sf, self.root_path)
                    lis += [StatusObject(sf, relpath, STATUS_UNVERSIONED)]
                continue

            if status == STATUS_NORMAL:
                continue

            relpath = browser.relative_path(f.path, self.root_path)
            lis += [StatusObject(f.path, relpath, status)]

        return lis

    def empty_status(self, abspath):
        """Get the status of the given abspath. We don't care of any child if
        it is a folder
        """
        try:
            changes = self.client.status(abspath,
                                         depth=pysvn.depth.empty,
                                         get_all=False)
            if not changes:
                status = STATUS_NORMAL
            else:
                assert(len(changes) == 1)
                status = PYSVN_STATUS_MAPPING[changes[0].text_status]
        except pysvn.ClientError, e:
            if str(e).endswith('is not a working copy'):
                status = STATUS_UNVERSIONED
            else:
                raise

        relpath = browser.relative_path(abspath, self.root_path)
        return StatusObject(abspath, relpath, status)

    def status(self, path=None):
        abspath = self.root_path
        if path:
            abspath = browser.absolute_path(path, self.root_path)
        try:
            changes = self.client.status(abspath, recurse=False, get_all=True)
            return self._status(abspath, changes)
        except pysvn.ClientError, e:
            if not str(e).endswith('is not a working copy'):
                raise
            # The file/folder is not in working copy so we force the status to
            # unversioned
            return [
                StatusObject(abspath, path, STATUS_UNVERSIONED)
            ]

    def full_status(self, path=None):
        abspath = self.root_path
        if path:
            abspath = browser.absolute_path(path, self.root_path)
        try:
            changes = self.client.status(abspath, recurse=True, get_all=False)
            return self._status(abspath, changes, short=False)
        except pysvn.ClientError, e:
            if not str(e).endswith('is not a working copy'):
                raise
            # The file/folder is not in working copy so we force the status to
            # unversioned
            return [
                StatusObject(abspath, path, STATUS_UNVERSIONED)
            ]

    def update(self, path=None):
        abspath = self.root_path
        if path:
            abspath = browser.absolute_path(path, self.root_path)
        # NOTE: use pysvn.depth.unknown to follow the client repo depths
        self.client.update(abspath, depth=pysvn.depth.unknown)

    def diff(self, path=None):
        diffs = []
        lis = self.full_status(path)
        tmp = tempfile.mkdtemp()
        for so in lis:
            if so.status == STATUS_CONFLICTED:
                continue
            if so.status in [STATUS_UNVERSIONED, STATUS_ADDED]:
                content = open(so.abspath, 'r').read()
                diffs += ['New file %s\n\n%s' % (so.relpath, content)]
            elif so.status in [STATUS_DELETED, STATUS_MISSING]:
                diffs += ['Deleted file %s' % so.relpath]
            else:
                s = self.client.diff(tmp, so.abspath)
                s = s.replace(self.root_path + '/', '')
                diffs += [s]
        return diffs

    def full_diff(self, path=None):
        diffs = []
        lis = self.full_status(path)
        d = diff.HtmlDiff()
        for so in lis:
            if so.status == STATUS_CONFLICTED:
                continue
            if so.status in [STATUS_DELETED, STATUS_MISSING]:
                new_content = ''
            else:
                new_content = open(so.abspath, 'r').read()
            if so.status in [STATUS_UNVERSIONED, STATUS_ADDED]:
                old_content = ''
            else:
                # old_content = self.client.cat(so.abspath)
                info = self.client.info(so.abspath)
                old_rev = pysvn.Revision(pysvn.opt_revision_kind.number,
                                         info.revision.number)
                old_content = self.client.cat(so.abspath, old_rev)
            diffs += [(
                so.relpath,
                d.make_table(
                    old_content.decode('utf-8').splitlines(),
                    new_content.decode('utf-8').splitlines())
            )]
        return diffs

    def get_commitable_files(self, path=None):
        lis = self.full_status(path)
        # For now we just skip the conflicted file.
        conflicteds = []
        tmps = []
        for so in lis:
            if so.status == STATUS_CONFLICTED:
                conflicteds += [so.abspath]
            else:
                tmps += [so]
        return [so for so in tmps if not is_conflicted(so, conflicteds)]

    def unversioned_parents(self, abspath):
        lis = []
        if abspath == self.root_path:
            return lis
        dirpath = os.path.dirname(abspath)
        while dirpath != self.root_path:
            so = self.empty_status(dirpath)
            if so.status == STATUS_UNVERSIONED:
                lis += [dirpath]
                dirpath = os.path.dirname(dirpath)
            else:
                return reversed(lis)
        return reversed(lis)

    def add(self, paths):
        """Add the file(s) to be commited

        :param paths: path of the file(s) to commit
        :param paths: str or list
        """
        if not isinstance(paths, list):
            paths = [paths]

        abspaths = []
        for path in paths:
            abspath = browser.absolute_path(path, self.root_path)
            if self.empty_status(abspath).status != STATUS_UNVERSIONED:
                continue
            for dirpath in self.unversioned_parents(abspath):
                # add the unversioned directory
                self.client.add(dirpath, depth=pysvn.depth.empty)
                abspaths += [dirpath]
            self.client.add(abspath)
            abspaths += [abspath]
        return abspaths

    def commit(self, paths, msg):
        """Commit file(s)

        :param paths: path of the file(s) to commit
        :type paths: str or list
        :param msg: the commit message
        :type msg: str
        """
        if not isinstance(paths, list):
            paths = [paths]

        errors = []
        abspaths = []
        for path in paths:
            abspath = browser.absolute_path(path, self.root_path)
            if os.path.isfile(abspath):
                abspaths += [abspath]
            if self.empty_status(abspath).status == STATUS_CONFLICTED:
                errors += ['Can\'t commit conflicted file: %s' % path]

        if errors:
            # TODO: create a custom expection?
            raise Exception('\n'.join(errors))

        # Add all the files
        # TODO: we should make a cache of the versioning status
        rpaths = self.add(paths)
        for rpath in rpaths:
            if rpath not in abspaths:
                abspaths += [rpath]
        self.client.checkin(abspaths, msg)

    def resolve(self, path):
        """Resolve the conflict on the given path (filename)
        """
        abspath = browser.absolute_path(path, self.root_path)
        # NOTE: we don't check abspath is conflicted since self.client.resolved
        # don't raise exception
        self.client.resolved(abspath)

    def has_conflict(self, path=None):
        lis = self.full_status(path)
        for so in lis:
            if so.status == STATUS_CONFLICTED:
                return True
        return False
